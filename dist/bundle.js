/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./game.js":
/*!*****************!*\
  !*** ./game.js ***!
  \*****************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _src_utils_Utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/utils/Utils */ \"./src/utils/Utils.js\");\n/* harmony import */ var _src_createAirplaneMesh_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/createAirplaneMesh.js */ \"./src/createAirplaneMesh.js\");\n/* harmony import */ var _src_components_Cloud_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/components/Cloud.js */ \"./src/components/Cloud.js\");\n/* harmony import */ var _src_managers_AudioManager_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/managers/AudioManager.js */ \"./src/managers/AudioManager.js\");\n/* harmony import */ var _src_managers_loadingProgressManager_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/managers/loadingProgressManager.js */ \"./src/managers/loadingProgressManager.js\");\n/* harmony import */ var _src_managers_ModelManager_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/managers/ModelManager.js */ \"./src/managers/ModelManager.js\");\n/* harmony import */ var _src_utils_Colors__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./src/utils/Colors */ \"./src/utils/Colors.js\");\n\n\n\n\n\n\n\nlet sky;\nclass SceneManager {\n  constructor() {\n    this.list = new Set();\n  }\n  add(obj) {\n    scene.add(obj.mesh);\n    this.list.add(obj);\n  }\n  remove(obj) {\n    scene.remove(obj.mesh);\n    this.list.delete(obj);\n  }\n  clear() {\n    for (const entry of this.list) {\n      this.remove(entry);\n    }\n  }\n  tick(deltaTime) {\n    for (const entry of this.list) {\n      if (entry.tick) {\n        entry.tick(deltaTime);\n      }\n    }\n  }\n}\nconst sceneManager = new SceneManager();\n\n///////////////\n// GAME VARIABLES\nvar canDie = true;\nvar world, game;\nvar newTime = new Date().getTime();\nvar oldTime = new Date().getTime();\nlet scene, camera, renderer;\n\n//SCREEN & MOUSE VARIABLES\nvar MAX_WORLD_X = 1000;\n\n//INIT THREE JS, SCREEN AND MOUSE EVENTS\nfunction createScene() {\n  scene = new THREE.Scene();\n  camera = new THREE.PerspectiveCamera(50, ui.width / ui.height, 0.1, 10000);\n  _src_managers_AudioManager_js__WEBPACK_IMPORTED_MODULE_3__.audioManager.setCamera(camera);\n  scene.fog = new THREE.Fog(0xf7d9aa, 100, 950);\n  renderer = new THREE.WebGLRenderer({\n    canvas: ui.canvas,\n    alpha: true,\n    antialias: true\n  });\n  renderer.setSize(ui.width, ui.height);\n  renderer.setPixelRatio(window.devicePixelRatio ? window.devicePixelRatio : 1);\n  renderer.shadowMap.enabled = true;\n  function setupCamera() {\n    renderer.setSize(ui.width, ui.height);\n    camera.aspect = ui.width / ui.height;\n    camera.updateProjectionMatrix();\n\n    // setTimeout(() => {\n    // \tconst rayCaster = new THREE.Raycaster()\n    // \trayCaster.setFromCamera(new THREE.Vector2(1, 1), camera)\n    // \tconst plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0)\n    // \tconst intersectPoint = new THREE.Vector3()\n    // \trayCaster.ray.intersectPlane(plane, intersectPoint)\n    // \tconsole.log('max world x:', intersectPoint.x)\n    // \t// MAX_WORLD_X = intersectPoint.x  doesn't work with first person view\n    // }, 500)\n  }\n  setupCamera();\n  ui.onResize(setupCamera);\n\n  // const controls = new THREE.OrbitControls(camera, renderer.domElement)\n  // controls.minPolarAngle = -Math.PI / 2\n  // controls.maxPolarAngle = Math.PI\n  // controls.addEventListener('change', () => {\n  // \tconsole.log('camera changed', 'camera=', camera.position, ', airplane=', airplane.position, 'camera.rotation=', camera.rotation)\n  // })\n  // setTimeout(() => {\n  // \tcamera.lookAt(airplane.mesh.position)\n  // \tcontrols.target.copy(airplane.mesh.position)\n  // }, 100)\n\n  // controls.noZoom = true\n  //controls.noPan = true\n\n  // handleWindowResize()\n}\n\n// LIGHTS\nvar ambientLight;\nfunction createLights() {\n  const hemisphereLight = new THREE.HemisphereLight(0xaaaaaa, 0x000000, 0.9);\n  ambientLight = new THREE.AmbientLight(0xdc8874, 0.5);\n  const shadowLight = new THREE.DirectionalLight(0xffffff, 0.9);\n  shadowLight.position.set(150, 350, 350);\n  shadowLight.castShadow = true;\n  shadowLight.shadow.camera.left = -400;\n  shadowLight.shadow.camera.right = 400;\n  shadowLight.shadow.camera.top = 400;\n  shadowLight.shadow.camera.bottom = -400;\n  shadowLight.shadow.camera.near = 1;\n  shadowLight.shadow.camera.far = 1000;\n  shadowLight.shadow.mapSize.width = 4096;\n  shadowLight.shadow.mapSize.height = 4096;\n  scene.add(hemisphereLight);\n  scene.add(shadowLight);\n  scene.add(ambientLight);\n}\n\n// GUNS\nclass SimpleGun {\n  constructor() {\n    this.mesh = SimpleGun.createMesh();\n    this.mesh.position.z = 28;\n    this.mesh.position.x = 25;\n    this.mesh.position.y = -8;\n  }\n  static createMesh() {\n    const metalMaterial = new THREE.MeshStandardMaterial({\n      color: 0x222222,\n      flatShading: true,\n      roughness: 0.5,\n      metalness: 1.0\n    });\n    const BODY_RADIUS = 3;\n    const BODY_LENGTH = 20;\n    const full = new THREE.Group();\n    const body = new THREE.Mesh(new THREE.CylinderGeometry(BODY_RADIUS, BODY_RADIUS, BODY_LENGTH), metalMaterial);\n    body.rotation.z = Math.PI / 2;\n    full.add(body);\n    const barrel = new THREE.Mesh(new THREE.CylinderGeometry(BODY_RADIUS / 2, BODY_RADIUS / 2, BODY_LENGTH), metalMaterial);\n    barrel.rotation.z = Math.PI / 2;\n    barrel.position.x = BODY_LENGTH;\n    full.add(barrel);\n    return full;\n  }\n  downtime() {\n    return 0.1;\n  }\n  damage() {\n    return 1;\n  }\n  shoot(direction) {\n    const BULLET_SPEED = 0.5;\n    const RECOIL_DISTANCE = 4;\n    const RECOIL_DURATION = this.downtime() / 1.5;\n    const position = new THREE.Vector3();\n    this.mesh.getWorldPosition(position);\n    position.add(new THREE.Vector3(5, 0, 0));\n    spawnProjectile(this.damage(), position, direction, BULLET_SPEED, 0.3, 3);\n\n    // Little explosion at exhaust\n    spawnParticles(position.clone().add(new THREE.Vector3(2, 0, 0)), 1, _src_utils_Colors__WEBPACK_IMPORTED_MODULE_6__.Colors.orange, 0.2);\n\n    // audio\n    _src_managers_AudioManager_js__WEBPACK_IMPORTED_MODULE_3__.audioManager.play(\"shot-soft\");\n\n    // Recoil of gun\n    const initialX = this.mesh.position.x;\n    TweenMax.to(this.mesh.position, {\n      duration: RECOIL_DURATION / 2,\n      x: initialX - RECOIL_DISTANCE,\n      onComplete: () => {\n        TweenMax.to(this.mesh.position, {\n          duration: RECOIL_DURATION / 2,\n          x: initialX\n        });\n      }\n    });\n  }\n}\nclass DoubleGun {\n  constructor() {\n    this.gun1 = new SimpleGun();\n    this.gun2 = new SimpleGun();\n    this.gun2.mesh.position.add(new THREE.Vector3(0, 14, 0));\n    this.mesh = new THREE.Group();\n    this.mesh.add(this.gun1.mesh);\n    this.mesh.add(this.gun2.mesh);\n  }\n  downtime() {\n    return 0.15;\n  }\n  damage() {\n    return this.gun1.damage() + this.gun2.damage();\n  }\n  shoot(direction) {\n    this.gun1.shoot(direction);\n    this.gun2.shoot(direction);\n  }\n}\nclass BetterGun {\n  constructor() {\n    this.mesh = BetterGun.createMesh();\n    this.mesh.position.z = 28;\n    this.mesh.position.x = -3;\n    this.mesh.position.y = -5;\n  }\n  static createMesh() {\n    const metalMaterial = new THREE.MeshStandardMaterial({\n      color: 0x222222,\n      flatShading: true,\n      roughness: 0.5,\n      metalness: 1.0\n    });\n    const BODY_RADIUS = 5;\n    const BODY_LENGTH = 30;\n    const full = new THREE.Group();\n    const body = new THREE.Mesh(new THREE.CylinderGeometry(BODY_RADIUS, BODY_RADIUS, BODY_LENGTH), metalMaterial);\n    body.rotation.z = Math.PI / 2;\n    body.position.x = BODY_LENGTH / 2;\n    full.add(body);\n    const BARREL_RADIUS = BODY_RADIUS / 2;\n    const BARREL_LENGTH = BODY_LENGTH * 0.66;\n    const barrel = new THREE.Mesh(new THREE.CylinderGeometry(BARREL_RADIUS, BARREL_RADIUS, BARREL_LENGTH), metalMaterial);\n    barrel.rotation.z = Math.PI / 2;\n    barrel.position.x = BODY_LENGTH + BARREL_LENGTH / 2;\n    full.add(barrel);\n    const TIP_RADIUS = BARREL_RADIUS * 1.3;\n    const TIP_LENGTH = BODY_LENGTH / 4;\n    const tip = new THREE.Mesh(new THREE.CylinderGeometry(TIP_RADIUS, TIP_RADIUS, TIP_LENGTH), metalMaterial);\n    tip.rotation.z = Math.PI / 2;\n    tip.position.x = BODY_LENGTH + BARREL_LENGTH + TIP_LENGTH / 2;\n    full.add(tip);\n    return full;\n  }\n  downtime() {\n    return 0.1;\n  }\n  damage() {\n    return 5;\n  }\n  shoot(direction) {\n    const BULLET_SPEED = 0.5;\n    const RECOIL_DISTANCE = 4;\n    const RECOIL_DURATION = this.downtime() / 3;\n\n    // position = position.clone().add(new THREE.Vector3(11.5, -1.3, 7.5))\n    const position = new THREE.Vector3();\n    this.mesh.getWorldPosition(position);\n    position.add(new THREE.Vector3(12, 0, 0));\n    spawnProjectile(this.damage(), position, direction, BULLET_SPEED, 0.8, 6);\n\n    // Little explosion at exhaust\n    spawnParticles(position.clone().add(new THREE.Vector3(2, 0, 0)), 3, _src_utils_Colors__WEBPACK_IMPORTED_MODULE_6__.Colors.orange, 0.5);\n\n    // audio\n    _src_managers_AudioManager_js__WEBPACK_IMPORTED_MODULE_3__.audioManager.play(\"shot-hard\");\n\n    // Recoil of gun\n    const initialX = this.mesh.position.x;\n    TweenMax.to(this.mesh.position, {\n      duration: RECOIL_DURATION,\n      x: initialX - RECOIL_DISTANCE,\n      onComplete: () => {\n        TweenMax.to(this.mesh.position, {\n          duration: RECOIL_DURATION,\n          x: initialX\n        });\n      }\n    });\n  }\n}\nclass Airplane {\n  constructor() {\n    const [mesh, propeller, pilot] = (0,_src_createAirplaneMesh_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])();\n    this.mesh = mesh;\n    this.propeller = propeller;\n    this.pilot = pilot;\n    this.weapon = null;\n    this.lastShot = 0;\n  }\n  equipWeapon(weapon) {\n    if (this.weapon) {\n      this.mesh.remove(this.weapon.mesh);\n    }\n    this.weapon = weapon;\n    if (this.weapon) {\n      this.mesh.add(this.weapon.mesh);\n    }\n  }\n  shoot() {\n    if (!this.weapon) {\n      return;\n    }\n\n    // rate-limit the shooting\n    const nowTime = new Date().getTime() / 1000;\n    const ready = nowTime - this.lastShot > this.weapon.downtime();\n    if (!ready) {\n      return;\n    }\n    this.lastShot = nowTime;\n\n    // fire the shot\n    let direction = new THREE.Vector3(10, 0, 0);\n    direction.applyEuler(airplane.mesh.rotation);\n    this.weapon.shoot(direction);\n\n    // recoil airplane\n    const recoilForce = this.weapon.damage();\n    TweenMax.to(this.mesh.position, {\n      duration: 0.05,\n      x: this.mesh.position.x - recoilForce\n    });\n  }\n  tick(deltaTime) {\n    this.propeller.rotation.x += 0.2 + game.planeSpeed * deltaTime * 0.005;\n    if (game.status === \"playing\") {\n      game.planeSpeed = _src_utils_Utils__WEBPACK_IMPORTED_MODULE_0__.utils.normalize(ui.mousePos.x, -0.5, 0.5, world.planeMinSpeed, world.planeMaxSpeed);\n      let targetX = _src_utils_Utils__WEBPACK_IMPORTED_MODULE_0__.utils.normalize(ui.mousePos.x, -1, 1, -world.planeAmpWidth * 0.7, -world.planeAmpWidth);\n      let targetY = _src_utils_Utils__WEBPACK_IMPORTED_MODULE_0__.utils.normalize(ui.mousePos.y, -0.75, 0.75, world.planeDefaultHeight - world.planeAmpHeight, world.planeDefaultHeight + world.planeAmpHeight);\n      game.planeCollisionDisplacementX += game.planeCollisionSpeedX;\n      targetX += game.planeCollisionDisplacementX;\n      game.planeCollisionDisplacementY += game.planeCollisionSpeedY;\n      targetY += game.planeCollisionDisplacementY;\n      this.mesh.position.x += (targetX - this.mesh.position.x) * deltaTime * world.planeMoveSensivity;\n      this.mesh.position.y += (targetY - this.mesh.position.y) * deltaTime * world.planeMoveSensivity;\n      this.mesh.rotation.x = (this.mesh.position.y - targetY) * deltaTime * world.planeRotZSensivity;\n      this.mesh.rotation.z = (targetY - this.mesh.position.y) * deltaTime * world.planeRotXSensivity;\n      if (game.fpv) {\n        camera.position.y = this.mesh.position.y + 20;\n        // camera.setRotationFromEuler(new THREE.Euler(-1.490248, -1.4124514, -1.48923231))\n        // camera.updateProjectionMatrix ()\n      } else {\n        camera.fov = _src_utils_Utils__WEBPACK_IMPORTED_MODULE_0__.utils.normalize(ui.mousePos.x, -30, 1, 40, 80);\n        camera.updateProjectionMatrix();\n        camera.position.y += (this.mesh.position.y - camera.position.y) * deltaTime * world.cameraSensivity;\n      }\n    }\n    game.planeCollisionSpeedX += (0 - game.planeCollisionSpeedX) * deltaTime * 0.03;\n    game.planeCollisionDisplacementX += (0 - game.planeCollisionDisplacementX) * deltaTime * 0.01;\n    game.planeCollisionSpeedY += (0 - game.planeCollisionSpeedY) * deltaTime * 0.03;\n    game.planeCollisionDisplacementY += (0 - game.planeCollisionDisplacementY) * deltaTime * 0.01;\n    this.pilot.updateHairs(deltaTime);\n  }\n  gethit(position) {\n    const diffPos = this.mesh.position.clone().sub(position);\n    const d = diffPos.length();\n    game.planeCollisionSpeedX = 100 * diffPos.x / d;\n    game.planeCollisionSpeedY = 100 * diffPos.y / d;\n    ambientLight.intensity = 2;\n    _src_managers_AudioManager_js__WEBPACK_IMPORTED_MODULE_3__.audioManager.play(\"airplane-crash\");\n  }\n}\nfunction rotateAroundSea(object, deltaTime, speed) {\n  object.angle += deltaTime * game.speed * world.collectiblesSpeed;\n  if (object.angle > Math.PI * 2) {\n    object.angle -= Math.PI * 2;\n  }\n  object.mesh.position.x = Math.cos(object.angle) * object.distance;\n  object.mesh.position.y = -world.seaRadius + Math.sin(object.angle) * object.distance;\n}\nclass Collectible {\n  constructor(mesh, onApply) {\n    this.angle = 0;\n    this.distance = 0;\n    this.onApply = onApply;\n    this.mesh = new THREE.Object3D();\n    const bubble = new THREE.Mesh(new THREE.SphereGeometry(10, 100, 100), new THREE.MeshPhongMaterial({\n      color: _src_utils_Colors__WEBPACK_IMPORTED_MODULE_6__.COLOR_COLLECTIBLE_BUBBLE,\n      transparent: true,\n      opacity: 0.4,\n      flatShading: true\n    }));\n    this.mesh.add(bubble);\n    this.mesh.add(mesh);\n    this.mesh.castShadow = true;\n\n    // for the angle:\n    //   Math.PI*2 * 0.0  => on the right side of the sea cylinder\n    //   Math.PI*2 * 0.1  => on the top right\n    //   Math.PI*2 * 0.2  => directly in front of the plane\n    //   Math.PI*2 * 0.3  => directly behind the plane\n    //   Math.PI*2 * 0.4  => on the top left\n    //   Math.PI*2 * 0.5  => on the left side\n    this.angle = Math.PI * 2 * 0.1;\n    this.distance = world.seaRadius + world.planeDefaultHeight + (-1 + 2 * Math.random()) * (world.planeAmpHeight - 20);\n    this.mesh.position.y = -world.seaRadius + Math.sin(this.angle) * this.distance;\n    this.mesh.position.x = Math.cos(this.angle) * this.distance;\n    sceneManager.add(this);\n  }\n  tick(deltaTime) {\n    rotateAroundSea(this, deltaTime, world.collectiblesSpeed);\n\n    // rotate collectible for visual effect\n    this.mesh.rotation.y += deltaTime * 0.002 * Math.random();\n    this.mesh.rotation.z += deltaTime * 0.002 * Math.random();\n\n    // collision?\n    if (_src_utils_Utils__WEBPACK_IMPORTED_MODULE_0__.utils.collide(airplane.mesh, this.mesh, world.collectibleDistanceTolerance)) {\n      this.onApply();\n      this.explode();\n    }\n    // passed-by?\n    else if (this.angle > Math.PI) {\n      sceneManager.remove(this);\n    }\n  }\n  explode() {\n    spawnParticles(this.mesh.position.clone(), 15, _src_utils_Colors__WEBPACK_IMPORTED_MODULE_6__.COLOR_COLLECTIBLE_BUBBLE, 3);\n    sceneManager.remove(this);\n    _src_managers_AudioManager_js__WEBPACK_IMPORTED_MODULE_3__.audioManager.play(\"bubble\");\n    const DURATION = 1;\n    setTimeout(() => {\n      const itemMesh = new THREE.Group();\n      for (let i = 1; i < this.mesh.children.length; i += 1) {\n        itemMesh.add(this.mesh.children[i]);\n      }\n      scene.add(itemMesh);\n      itemMesh.position.y = 120;\n      itemMesh.position.z = 50;\n      const initialScale = itemMesh.scale.clone();\n      TweenMax.to(itemMesh.scale, {\n        duration: DURATION / 2,\n        x: initialScale.x * 4,\n        y: initialScale.y * 4,\n        z: initialScale.z * 4,\n        ease: \"Power2.easeInOut\",\n        onComplete: () => {\n          TweenMax.to(itemMesh.scale, {\n            duration: DURATION / 2,\n            x: 0,\n            y: 0,\n            z: 0,\n            ease: \"Power2.easeInOut\",\n            onComplete: () => {\n              scene.remove(itemMesh);\n            }\n          });\n        }\n      });\n    }, 200);\n  }\n}\nfunction spawnSimpleGunCollectible() {\n  const gun = SimpleGun.createMesh();\n  gun.scale.set(0.25, 0.25, 0.25);\n  gun.position.x = -2;\n  new Collectible(gun, () => {\n    airplane.equipWeapon(new SimpleGun());\n  });\n}\nfunction spawnBetterGunCollectible() {\n  const gun = BetterGun.createMesh();\n  gun.scale.set(0.25, 0.25, 0.25);\n  gun.position.x = -7;\n  new Collectible(gun, () => {\n    airplane.equipWeapon(new BetterGun());\n  });\n}\nfunction spawnDoubleGunCollectible() {\n  const guns = new THREE.Group();\n  const gun1 = SimpleGun.createMesh();\n  gun1.scale.set(0.25, 0.25, 0.25);\n  gun1.position.x = -2;\n  gun1.position.y = -2;\n  guns.add(gun1);\n  const gun2 = SimpleGun.createMesh();\n  gun2.scale.set(0.25, 0.25, 0.25);\n  gun2.position.x = -2;\n  gun2.position.y = 2;\n  guns.add(gun2);\n  new Collectible(guns, () => {\n    airplane.equipWeapon(new DoubleGun());\n  });\n}\nfunction spawnLifeCollectible() {\n  const heart = _src_managers_ModelManager_js__WEBPACK_IMPORTED_MODULE_5__.modelManager.get(\"heart\");\n  heart.traverse(function (child) {\n    if (child instanceof THREE.Mesh) {\n      child.material.color.setHex(0xff0000);\n    }\n  });\n  heart.position.set(0, -1, -3);\n  heart.scale.set(5, 5, 5);\n  new Collectible(heart, () => {\n    addLife();\n  });\n}\nclass Sky {\n  constructor() {\n    this.mesh = new THREE.Object3D();\n    this.nClouds = 20;\n    this.clouds = [];\n    const stepAngle = Math.PI * 2 / this.nClouds;\n    for (let i = 0; i < this.nClouds; i++) {\n      const c = new _src_components_Cloud_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\n      this.clouds.push(c);\n      var a = stepAngle * i;\n      var h = world.seaRadius + 150 + Math.random() * 200;\n      c.mesh.position.y = Math.sin(a) * h;\n      c.mesh.position.x = Math.cos(a) * h;\n      c.mesh.position.z = -300 - Math.random() * 500;\n      c.mesh.rotation.z = a + Math.PI / 2;\n      const scale = 1 + Math.random() * 2;\n      c.mesh.scale.set(scale, scale, scale);\n      this.mesh.add(c.mesh);\n    }\n  }\n  tick(deltaTime) {\n    for (var i = 0; i < this.nClouds; i++) {\n      var c = this.clouds[i];\n      c.tick(deltaTime);\n    }\n    this.mesh.rotation.z += game.speed * deltaTime;\n  }\n}\nfunction createSky() {\n  sky = new Sky();\n  sky.mesh.position.y = -world.seaRadius;\n  scene.add(sky.mesh);\n}\nconst COLOR_SEA_LEVEL = [0x68c3c0,\n// hsl(178deg 43% 59%)\n0x47b3af,\n// hsl(178deg 43% 49%)\n0x398e8b,\n// hsl(178deg 43% 39%)\n0x2a6a68,\n// hsl(178deg 43% 29%)\n0x1c4544,\n// hsl(178deg 43% 19%)\n0x0d2120 // hsl(178deg 43% 09%)\n];\nclass Sea {\n  constructor() {\n    var geom = new THREE.CylinderGeometry(world.seaRadius, world.seaRadius, world.seaLength, 40, 10);\n    geom.applyMatrix4(new THREE.Matrix4().makeRotationX(-Math.PI / 2));\n    this.waves = [];\n    const arr = geom.attributes.position.array;\n    for (let i = 0; i < arr.length / 3; i++) {\n      this.waves.push({\n        x: arr[i * 3 + 0],\n        y: arr[i * 3 + 1],\n        z: arr[i * 3 + 2],\n        ang: Math.random() * Math.PI * 2,\n        amp: world.wavesMinAmp + Math.random() * (world.wavesMaxAmp - world.wavesMinAmp),\n        speed: world.wavesMinSpeed + Math.random() * (world.wavesMaxSpeed - world.wavesMinSpeed)\n      });\n    }\n    var mat = new THREE.MeshPhongMaterial({\n      color: COLOR_SEA_LEVEL[0],\n      transparent: true,\n      opacity: 0.8,\n      flatShading: true\n    });\n    this.mesh = new THREE.Mesh(geom, mat);\n    this.mesh.receiveShadow = true;\n  }\n  tick(deltaTime) {\n    var arr = this.mesh.geometry.attributes.position.array;\n    for (let i = 0; i < arr.length / 3; i++) {\n      var wave = this.waves[i];\n      arr[i * 3 + 0] = wave.x + Math.cos(wave.ang) * wave.amp;\n      arr[i * 3 + 1] = wave.y + Math.sin(wave.ang) * wave.amp;\n      wave.ang += wave.speed * deltaTime;\n    }\n    this.mesh.geometry.attributes.position.needsUpdate = true;\n  }\n  updateColor() {\n    this.mesh.material = new THREE.MeshPhongMaterial({\n      color: COLOR_SEA_LEVEL[(game.level - 1) % COLOR_SEA_LEVEL.length],\n      transparent: true,\n      opacity: 0.8,\n      flatShading: true\n    });\n  }\n}\nfunction spawnParticles(pos, count, color, scale) {\n  for (let i = 0; i < count; i++) {\n    const geom = new THREE.TetrahedronGeometry(3, 0);\n    const mat = new THREE.MeshPhongMaterial({\n      color: 0x009999,\n      shininess: 0,\n      specular: 0xffffff,\n      flatShading: true\n    });\n    const mesh = new THREE.Mesh(geom, mat);\n    scene.add(mesh);\n    mesh.visible = true;\n    mesh.position.copy(pos);\n    mesh.material.color = new THREE.Color(color);\n    mesh.material.needsUpdate = true;\n    mesh.scale.set(scale, scale, scale);\n    const targetX = pos.x + (-1 + Math.random() * 2) * 50;\n    const targetY = pos.y + (-1 + Math.random() * 2) * 50;\n    const targetZ = pos.z + (-1 + Math.random() * 2) * 50;\n    const speed = 0.6 + Math.random() * 0.2;\n    TweenMax.to(mesh.rotation, speed, {\n      x: Math.random() * 12,\n      y: Math.random() * 12\n    });\n    TweenMax.to(mesh.scale, speed, {\n      x: 0.1,\n      y: 0.1,\n      z: 0.1\n    });\n    TweenMax.to(mesh.position, speed, {\n      x: targetX,\n      y: targetY,\n      z: targetZ,\n      delay: Math.random() * 0.1,\n      ease: Power2.easeOut,\n      onComplete: () => {\n        scene.remove(mesh);\n      }\n    });\n  }\n}\n\n// ENEMIES\nclass Enemy {\n  constructor() {\n    var geom = new THREE.TetrahedronGeometry(8, 2);\n    var mat = new THREE.MeshPhongMaterial({\n      color: _src_utils_Colors__WEBPACK_IMPORTED_MODULE_6__.Colors.red,\n      shininess: 0,\n      specular: 0xffffff,\n      flatShading: true\n    });\n    this.mesh = new THREE.Mesh(geom, mat);\n    this.mesh.castShadow = true;\n    this.angle = 0;\n    this.distance = 0;\n    this.hitpoints = 3;\n    sceneManager.add(this);\n  }\n  tick(deltaTime) {\n    rotateAroundSea(this, deltaTime, world.enemiesSpeed);\n    this.mesh.rotation.y += Math.random() * 0.1;\n    this.mesh.rotation.z += Math.random() * 0.1;\n\n    // collision?\n    if (_src_utils_Utils__WEBPACK_IMPORTED_MODULE_0__.utils.collide(airplane.mesh, this.mesh, world.enemyDistanceTolerance) && game.status !== \"finished\") {\n      this.explode();\n      airplane.gethit(this.mesh.position);\n      removeLife();\n    }\n    // passed-by?\n    else if (this.angle > Math.PI) {\n      sceneManager.remove(this);\n    }\n    const thisAabb = new THREE.Box3().setFromObject(this.mesh);\n    for (const projectile of allProjectiles) {\n      const projectileAabb = new THREE.Box3().setFromObject(projectile.mesh);\n      if (thisAabb.intersectsBox(projectileAabb)) {\n        spawnParticles(projectile.mesh.position.clone(), 5, _src_utils_Colors__WEBPACK_IMPORTED_MODULE_6__.Colors.brownDark, 1);\n        projectile.remove();\n        this.hitpoints -= projectile.damage;\n        _src_managers_AudioManager_js__WEBPACK_IMPORTED_MODULE_3__.audioManager.play(\"bullet-impact\", {\n          volume: 0.3\n        });\n      }\n    }\n    if (this.hitpoints <= 0) {\n      this.explode();\n    }\n  }\n  explode() {\n    _src_managers_AudioManager_js__WEBPACK_IMPORTED_MODULE_3__.audioManager.play(\"rock-shatter\", {\n      volume: 3\n    });\n    spawnParticles(this.mesh.position.clone(), 15, _src_utils_Colors__WEBPACK_IMPORTED_MODULE_6__.Colors.red, 3);\n    sceneManager.remove(this);\n    game.statistics.enemiesKilled += 1;\n  }\n}\nfunction spawnEnemies(count) {\n  for (let i = 0; i < count; i++) {\n    const enemy = new Enemy();\n    enemy.angle = -(i * 0.1);\n    enemy.distance = world.seaRadius + world.planeDefaultHeight + (-1 + Math.random() * 2) * (world.planeAmpHeight - 20);\n    enemy.mesh.position.x = Math.cos(enemy.angle) * enemy.distance;\n    enemy.mesh.position.y = -world.seaRadius + Math.sin(enemy.angle) * enemy.distance;\n  }\n  game.statistics.enemiesSpawned += count;\n}\n\n// COINS\nclass Coin {\n  constructor() {\n    var geom = new THREE.CylinderGeometry(4, 4, 1, 10);\n    var mat = new THREE.MeshPhongMaterial({\n      color: _src_utils_Colors__WEBPACK_IMPORTED_MODULE_6__.COLOR_COINS,\n      shininess: 1,\n      specular: 0xffffff,\n      flatShading: true\n    });\n    this.mesh = new THREE.Mesh(geom, mat);\n    this.mesh.castShadow = true;\n    this.angle = 0;\n    this.dist = 0;\n    sceneManager.add(this);\n  }\n  tick(deltaTime) {\n    rotateAroundSea(this, deltaTime, world.coinsSpeed);\n    this.mesh.rotation.z += Math.random() * 0.1;\n    this.mesh.rotation.y += Math.random() * 0.1;\n\n    // collision?\n    if (_src_utils_Utils__WEBPACK_IMPORTED_MODULE_0__.utils.collide(airplane.mesh, this.mesh, world.coinDistanceTolerance)) {\n      spawnParticles(this.mesh.position.clone(), 5, _src_utils_Colors__WEBPACK_IMPORTED_MODULE_6__.COLOR_COINS, 0.8);\n      addCoin();\n      _src_managers_AudioManager_js__WEBPACK_IMPORTED_MODULE_3__.audioManager.play(\"coin\", {\n        volume: 0.5\n      });\n      sceneManager.remove(this);\n    }\n    // passed-by?\n    else if (this.angle > Math.PI) {\n      sceneManager.remove(this);\n    }\n  }\n}\nfunction spawnCoins() {\n  const nCoins = 1 + Math.floor(Math.random() * 10);\n  const d = world.seaRadius + world.planeDefaultHeight + _src_utils_Utils__WEBPACK_IMPORTED_MODULE_0__.utils.randomFromRange(-1, 1) * (world.planeAmpHeight - 20);\n  const amplitude = 10 + Math.round(Math.random() * 10);\n  for (let i = 0; i < nCoins; i++) {\n    const coin = new Coin();\n    coin.angle = -(i * 0.02);\n    coin.distance = d + Math.cos(i * 0.5) * amplitude;\n    coin.mesh.position.y = -world.seaRadius + Math.sin(coin.angle) * coin.distance;\n    coin.mesh.position.x = Math.cos(coin.angle) * coin.distance;\n  }\n  game.statistics.coinsSpawned += nCoins;\n}\n\n// SHOOTING\nlet allProjectiles = [];\nclass Projectile {\n  constructor(damage, initialPosition, direction, speed, radius, length) {\n    const PROJECTILE_COLOR = _src_utils_Colors__WEBPACK_IMPORTED_MODULE_6__.Colors.brownDark; // 0x333333\n\n    this.damage = damage;\n    this.mesh = new THREE.Mesh(new THREE.CylinderGeometry(radius, radius, length), new THREE.LineBasicMaterial({\n      color: PROJECTILE_COLOR\n    }));\n    this.mesh.position.copy(initialPosition);\n    this.mesh.rotation.z = Math.PI / 2;\n    this.direction = direction.clone();\n    this.direction.setLength(1);\n    this.speed = speed;\n    sceneManager.add(this);\n    game.statistics.shotsFired += 1;\n  }\n  tick(deltaTime) {\n    this.mesh.position.add(this.direction.clone().multiplyScalar(this.speed * deltaTime));\n    this.mesh.position.z *= 0.9;\n    // out of screen? => remove\n    if (this.mesh.position.x > MAX_WORLD_X) {\n      this.remove();\n    }\n  }\n  remove() {\n    sceneManager.remove(this);\n    allProjectiles.splice(allProjectiles.indexOf(this), 1);\n  }\n}\nfunction spawnProjectile(damage, initialPosition, direction, speed, radius, length) {\n  allProjectiles.push(new Projectile(damage, initialPosition, direction, speed, radius, length));\n}\n\n// 3D Models\nlet sea, sea2;\nlet airplane;\nfunction createPlane() {\n  airplane = new Airplane();\n  airplane.mesh.scale.set(0.25, 0.25, 0.25);\n  airplane.mesh.position.y = world.planeDefaultHeight;\n  scene.add(airplane.mesh);\n}\nfunction createSea() {\n  // We create a second sea that is not animated because the animation of our our normal sea leaves holes at certain points and I don't know how to get rid of them. These holes did not occur in the original script that used three js version 75 and mergeVertices. However, I tried to reproduce that behaviour in the animation function but without succes - thus this workaround here.\n  sea = new Sea();\n  sea.mesh.position.y = -world.seaRadius;\n  scene.add(sea.mesh);\n  sea2 = new Sea();\n  sea2.mesh.position.y = -world.seaRadius;\n  scene.add(sea2.mesh);\n}\nfunction loop() {\n  newTime = new Date().getTime();\n  const deltaTime = newTime - oldTime;\n  oldTime = newTime;\n  if (game.status == \"playing\") {\n    if (!game.paused) {\n      // Add coins\n      if (Math.floor(game.distance) % world.distanceForCoinsSpawn == 0 && Math.floor(game.distance) > game.coinLastSpawn) {\n        game.coinLastSpawn = Math.floor(game.distance);\n        spawnCoins();\n      }\n      if (Math.floor(game.distance) % world.distanceForSpeedUpdate == 0 && Math.floor(game.distance) > game.speedLastUpdate) {\n        game.speedLastUpdate = Math.floor(game.distance);\n        game.targetBaseSpeed += world.incrementSpeedByTime * deltaTime;\n      }\n      if (Math.floor(game.distance) % world.distanceForEnemiesSpawn == 0 && Math.floor(game.distance) > game.enemyLastSpawn) {\n        game.enemyLastSpawn = Math.floor(game.distance);\n        spawnEnemies(game.level);\n      }\n      if (Math.floor(game.distance) % world.distanceForLevelUpdate == 0 && Math.floor(game.distance) > game.levelLastUpdate) {\n        game.levelLastUpdate = Math.floor(game.distance);\n        game.level += 1;\n        if (game.level === world.levelCount) {\n          game.status = \"finished\";\n          setFollowView();\n          ui.showScoreScreen();\n        } else {\n          ui.informNextLevel(game.level);\n          sea.updateColor();\n          sea2.updateColor();\n          ui.updateLevelCount();\n          game.targetBaseSpeed = world.initSpeed + world.incrementSpeedByLevel * game.level;\n        }\n      }\n\n      // span collectibles\n      if (game.lifes < world.maxLifes && game.distance - game.lastLifeSpawn > world.pauseLifeSpawn && Math.random() < 0.01) {\n        game.lastLifeSpawn = game.distance;\n        spawnLifeCollectible();\n      }\n      if (!game.spawnedSimpleGun && game.distance > world.simpleGunLevelDrop * world.distanceForLevelUpdate) {\n        spawnSimpleGunCollectible();\n        game.spawnedSimpleGun = true;\n      }\n      if (!game.spawnedDoubleGun && game.distance > world.doubleGunLevelDrop * world.distanceForLevelUpdate) {\n        spawnDoubleGunCollectible();\n        game.spawnedDoubleGun = true;\n      }\n      if (!game.spawnedBetterGun && game.distance > world.betterGunLevelDrop * world.distanceForLevelUpdate) {\n        spawnBetterGunCollectible();\n        game.spawnedBetterGun = true;\n      }\n      if (ui.mouseButtons[0] || ui.keysDown[\"Space\"]) {\n        airplane.shoot();\n      }\n      airplane.tick(deltaTime);\n      game.distance += game.speed * deltaTime * world.ratioSpeedDistance;\n      game.baseSpeed += (game.targetBaseSpeed - game.baseSpeed) * deltaTime * 0.02;\n      game.speed = game.baseSpeed * game.planeSpeed;\n      ui.updateDistanceDisplay();\n      if (game.lifes <= 0 && canDie) {\n        game.status = \"gameover\";\n      }\n    }\n  } else if (game.status == \"gameover\") {\n    game.speed *= 0.99;\n    airplane.mesh.rotation.z += (-Math.PI / 2 - airplane.mesh.rotation.z) * 0.0002 * deltaTime;\n    airplane.mesh.rotation.x += 0.0003 * deltaTime;\n    game.planeFallSpeed *= 1.05;\n    airplane.mesh.position.y -= game.planeFallSpeed * deltaTime;\n    if (airplane.mesh.position.y < -200) {\n      ui.showReplay();\n      game.status = \"waitingReplay\";\n      _src_managers_AudioManager_js__WEBPACK_IMPORTED_MODULE_3__.audioManager.play(\"water-splash\");\n    }\n  } else if (game.status == \"waitingReplay\") {\n    // nothing to do\n  }\n  if (!game.paused) {\n    airplane.tick(deltaTime);\n    sea.mesh.rotation.z += game.speed * deltaTime;\n    if (sea.mesh.rotation.z > 2 * Math.PI) {\n      sea.mesh.rotation.z -= 2 * Math.PI;\n    }\n    ambientLight.intensity += (0.5 - ambientLight.intensity) * deltaTime * 0.005;\n    sceneManager.tick(deltaTime);\n    sky.tick(deltaTime);\n    sea.tick(deltaTime);\n  }\n  renderer.render(scene, camera);\n  requestAnimationFrame(loop);\n}\n\n// COINS\nfunction addCoin() {\n  game.coins += 1;\n  ui.updateCoinsCount(game.coins);\n  game.statistics.coinsCollected += 1;\n}\nfunction addLife() {\n  game.lifes = Math.min(world.maxLifes, game.lifes + 1);\n  ui.updateLifesDisplay();\n}\nfunction removeLife() {\n  game.lifes = Math.max(0, game.lifes - 1);\n  ui.updateLifesDisplay();\n  game.statistics.lifesLost += 1;\n}\nfunction setSideView() {\n  game.fpv = false;\n  camera.position.set(0, world.planeDefaultHeight, 200);\n  camera.setRotationFromEuler(new THREE.Euler(0, 0, 0));\n}\nfunction setFollowView() {\n  game.fpv = true;\n  camera.position.set(-89, airplane.mesh.position.y + 20, 0);\n  camera.setRotationFromEuler(new THREE.Euler(-1.490248, -1.4124514, -1.48923231));\n  camera.updateProjectionMatrix();\n}\nclass UI {\n  constructor(onStart) {\n    this._elemDistanceCounter = document.getElementById(\"distValue\");\n    this._elemReplayMessage = document.getElementById(\"replayMessage\");\n    this._elemLevelCounter = document.getElementById(\"levelValue\");\n    this._elemLevelCircle = document.getElementById(\"levelCircleStroke\");\n    this._elemsLifes = document.querySelectorAll(\"#lifes img\");\n    this._elemCoinsCount = document.getElementById(\"coinsValue\");\n    document.querySelector(\"#intro-screen button\").onclick = () => {\n      document.getElementById(\"intro-screen\").classList.remove(\"visible\");\n      onStart();\n    };\n    document.addEventListener(\"keydown\", this.handleKeyDown.bind(this), false);\n    document.addEventListener(\"keyup\", this.handleKeyUp.bind(this), false);\n    document.addEventListener(\"mousedown\", this.handleMouseDown.bind(this), false);\n    document.addEventListener(\"mouseup\", this.handleMouseUp.bind(this), false);\n    document.addEventListener(\"mousemove\", this.handleMouseMove.bind(this), false);\n    document.addEventListener(\"blur\", this.handleBlur.bind(this), false);\n    document.oncontextmenu = document.body.oncontextmenu = function () {\n      return false;\n    };\n    window.addEventListener(\"resize\", this.handleWindowResize.bind(this), false);\n    this.width = window.innerWidth;\n    this.height = window.innerHeight;\n    this.mousePos = {\n      x: 0,\n      y: 0\n    };\n    this.canvas = document.getElementById(\"threejs-canvas\");\n    this.mouseButtons = [false, false, false];\n    this.keysDown = {};\n    this._resizeListeners = [];\n  }\n  onResize(callback) {\n    this._resizeListeners.push(callback);\n  }\n  handleWindowResize(event) {\n    this.width = window.innerWidth;\n    this.height = window.innerHeight;\n    for (const listener of this._resizeListeners) {\n      listener();\n    }\n  }\n  handleMouseMove(event) {\n    var tx = -1 + event.clientX / this.width * 2;\n    var ty = 1 - event.clientY / this.height * 2;\n    this.mousePos = {\n      x: tx,\n      y: ty\n    };\n  }\n  handleTouchMove(event) {\n    event.preventDefault();\n    var tx = -1 + event.touches[0].pageX / this.width * 2;\n    var ty = 1 - event.touches[0].pageY / this.height * 2;\n    this.mousePos = {\n      x: tx,\n      y: ty\n    };\n  }\n  handleMouseDown(event) {\n    this.mouseButtons[event.button] = true;\n    if (event.button === 1 && game.status === \"playing\") {\n      airplane.shoot();\n    }\n  }\n  handleKeyDown(event) {\n    this.keysDown[event.code] = true;\n    if (event.code === \"KeyP\") {\n      game.paused = !game.paused;\n    }\n    if (event.code === \"Space\") {\n      airplane.shoot();\n    }\n    if (event.code === \"Enter\") {\n      if (game.fpv) {\n        setSideView();\n      } else {\n        setFollowView();\n      }\n    }\n  }\n  handleKeyUp(event) {\n    this.keysDown[event.code] = false;\n  }\n  handleMouseUp(event) {\n    this.mouseButtons[event.button] = false;\n    event.preventDefault();\n    if (game && game.status == \"waitingReplay\") {\n      resetMap();\n      ui.informNextLevel(1);\n      game.paused = false;\n      sea.updateColor();\n      sea2.updateColor();\n      ui.updateDistanceDisplay();\n      ui.updateLevelCount();\n      ui.updateLifesDisplay();\n      ui.updateCoinsCount();\n      ui.hideReplay();\n    }\n  }\n  handleBlur(event) {\n    this.mouseButtons = [false, false, false];\n  }\n\n  // function handleTouchEnd(event) {\n  // \tif (game.status == \"waitingReplay\"){\n  // \t\tresetGame()\n  // \t\tui.hideReplay()\n  // \t}\n  // }\n\n  showReplay() {\n    this._elemReplayMessage.style.display = \"block\";\n  }\n  hideReplay() {\n    this._elemReplayMessage.style.display = \"none\";\n  }\n  updateLevelCount() {\n    this._elemLevelCounter.innerText = game.level;\n  }\n  updateCoinsCount() {\n    this._elemCoinsCount.innerText = game.coins;\n  }\n  updateDistanceDisplay() {\n    this._elemDistanceCounter.innerText = Math.floor(game.distance);\n    const d = 502 * (1 - game.distance % world.distanceForLevelUpdate / world.distanceForLevelUpdate);\n    this._elemLevelCircle.setAttribute(\"stroke-dashoffset\", d);\n  }\n  updateLifesDisplay() {\n    for (let i = 0, len = this._elemsLifes.length; i < len; i += 1) {\n      const hasThisLife = i < game.lifes;\n      const elem = this._elemsLifes[i];\n      if (hasThisLife && !elem.classList.contains(\"visible\")) {\n        elem.classList.remove(\"invisible\");\n        elem.classList.add(\"visible\");\n      } else if (!hasThisLife && !elem.classList.contains(\"invisible\")) {\n        elem.classList.remove(\"visible\");\n        elem.classList.add(\"invisible\");\n      }\n    }\n  }\n  informNextLevel(level) {\n    const ANIMATION_DURATION = 1.0;\n    const elem = document.getElementById(\"new-level\");\n    elem.style.visibility = \"visible\";\n    elem.style.animationDuration = Math.round(ANIMATION_DURATION * 1000) + \"ms\";\n    elem.children[1].innerText = level;\n    elem.classList.add(\"animating\");\n    setTimeout(() => {\n      document.getElementById(\"new-level\").style.visibility = \"hidden\";\n      elem.classList.remove(\"animating\");\n    }, 1000);\n  }\n  showScoreScreen() {\n    const elemScreen = document.getElementById(\"score-screen\");\n\n    // make visible\n    elemScreen.classList.add(\"visible\");\n\n    // fill in statistics\n    document.getElementById(\"score-coins-collected\").innerText = game.statistics.coinsCollected;\n    document.getElementById(\"score-coins-total\").innerText = game.statistics.coinsSpawned;\n    document.getElementById(\"score-enemies-killed\").innerText = game.statistics.enemiesKilled;\n    document.getElementById(\"score-enemies-total\").innerText = game.statistics.enemiesSpawned;\n    document.getElementById(\"score-shots-fired\").innerText = game.statistics.shotsFired;\n    document.getElementById(\"score-lifes-lost\").innerText = game.statistics.lifesLost;\n  }\n  showError(message) {\n    document.getElementById(\"error\").style.visibility = \"visible\";\n    document.getElementById(\"error-message\").innerText = message;\n  }\n}\nlet ui;\nfunction createWorld() {\n  world = {\n    initSpeed: 0.00035,\n    incrementSpeedByTime: 0.0000025,\n    incrementSpeedByLevel: 0.000005,\n    distanceForSpeedUpdate: 100,\n    ratioSpeedDistance: 50,\n    simpleGunLevelDrop: 1.1,\n    doubleGunLevelDrop: 2.3,\n    betterGunLevelDrop: 3.5,\n    maxLifes: 3,\n    pauseLifeSpawn: 400,\n    levelCount: 6,\n    distanceForLevelUpdate: 500,\n    planeDefaultHeight: 100,\n    planeAmpHeight: 80,\n    planeAmpWidth: 75,\n    planeMoveSensivity: 0.005,\n    planeRotXSensivity: 0.0008,\n    planeRotZSensivity: 0.0004,\n    planeMinSpeed: 1.2,\n    planeMaxSpeed: 1.6,\n    seaRadius: 600,\n    seaLength: 800,\n    wavesMinAmp: 5,\n    wavesMaxAmp: 20,\n    wavesMinSpeed: 0.001,\n    wavesMaxSpeed: 0.003,\n    cameraSensivity: 0.002,\n    coinDistanceTolerance: 15,\n    coinsSpeed: 0.5,\n    distanceForCoinsSpawn: 50,\n    collectibleDistanceTolerance: 15,\n    collectiblesSpeed: 0.6,\n    enemyDistanceTolerance: 10,\n    enemiesSpeed: 0.6,\n    distanceForEnemiesSpawn: 50\n  };\n\n  // create the world\n  createScene();\n  createSea();\n  createSky();\n  createLights();\n  createPlane();\n  resetMap();\n}\nfunction resetMap() {\n  game = {\n    status: \"playing\",\n    speed: 0,\n    paused: false,\n    baseSpeed: 0.00035,\n    targetBaseSpeed: 0.00035,\n    speedLastUpdate: 0,\n    distance: 0,\n    coins: 0,\n    fpv: false,\n    // gun spawning\n    spawnedSimpleGun: false,\n    spawnedDoubleGun: false,\n    spawnedBetterGun: false,\n    lastLifeSpawn: 0,\n    lifes: world.maxLifes,\n    level: 1,\n    levelLastUpdate: 0,\n    planeFallSpeed: 0.001,\n    planeSpeed: 0,\n    planeCollisionDisplacementX: 0,\n    planeCollisionSpeedX: 0,\n    planeCollisionDisplacementY: 0,\n    planeCollisionSpeedY: 0,\n    coinLastSpawn: 0,\n    enemyLastSpawn: 0,\n    statistics: {\n      coinsCollected: 0,\n      coinsSpawned: 0,\n      enemiesKilled: 0,\n      enemiesSpawned: 0,\n      shotsFired: 0,\n      lifesLost: 0\n    }\n  };\n\n  // update ui\n  ui.updateDistanceDisplay();\n  ui.updateLevelCount();\n  ui.updateLifesDisplay();\n  ui.updateCoinsCount();\n  sceneManager.clear();\n  sea.updateColor();\n  sea2.updateColor();\n  setSideView();\n  airplane.equipWeapon(null);\n\n  // airplane.equipWeapon(new SimpleGun())\n  // airplane.equipWeapon(new DoubleGun())\n  // airplane.equipWeapon(new BetterGun())\n}\nlet soundPlaying = false;\nfunction startMap() {\n  if (!soundPlaying) {\n    _src_managers_AudioManager_js__WEBPACK_IMPORTED_MODULE_3__.audioManager.play(\"propeller\", {\n      loop: true,\n      volume: 1\n    });\n    _src_managers_AudioManager_js__WEBPACK_IMPORTED_MODULE_3__.audioManager.play(\"ocean\", {\n      loop: true,\n      volume: 1\n    });\n    soundPlaying = true;\n  }\n  createWorld();\n  loop();\n  ui.informNextLevel(1);\n  game.paused = false;\n}\nfunction onWebsiteLoaded(event) {\n  // load audio\n  _src_managers_AudioManager_js__WEBPACK_IMPORTED_MODULE_3__.audioManager.load(\"ocean\", null, \"/audio/ocean.mp3\");\n  _src_managers_AudioManager_js__WEBPACK_IMPORTED_MODULE_3__.audioManager.load(\"propeller\", null, \"/audio/propeller.mp3\");\n  _src_managers_AudioManager_js__WEBPACK_IMPORTED_MODULE_3__.audioManager.load(\"coin-1\", \"coin\", \"/audio/coin-1.mp3\");\n  _src_managers_AudioManager_js__WEBPACK_IMPORTED_MODULE_3__.audioManager.load(\"coin-2\", \"coin\", \"/audio/coin-2.mp3\");\n  _src_managers_AudioManager_js__WEBPACK_IMPORTED_MODULE_3__.audioManager.load(\"coin-3\", \"coin\", \"/audio/coin-3.mp3\");\n  _src_managers_AudioManager_js__WEBPACK_IMPORTED_MODULE_3__.audioManager.load(\"jar-1\", \"coin\", \"/audio/jar-1.mp3\");\n  _src_managers_AudioManager_js__WEBPACK_IMPORTED_MODULE_3__.audioManager.load(\"jar-2\", \"coin\", \"/audio/jar-2.mp3\");\n  _src_managers_AudioManager_js__WEBPACK_IMPORTED_MODULE_3__.audioManager.load(\"jar-3\", \"coin\", \"/audio/jar-3.mp3\");\n  _src_managers_AudioManager_js__WEBPACK_IMPORTED_MODULE_3__.audioManager.load(\"jar-4\", \"coin\", \"/audio/jar-4.mp3\");\n  _src_managers_AudioManager_js__WEBPACK_IMPORTED_MODULE_3__.audioManager.load(\"jar-5\", \"coin\", \"/audio/jar-5.mp3\");\n  _src_managers_AudioManager_js__WEBPACK_IMPORTED_MODULE_3__.audioManager.load(\"jar-6\", \"coin\", \"/audio/jar-6.mp3\");\n  _src_managers_AudioManager_js__WEBPACK_IMPORTED_MODULE_3__.audioManager.load(\"jar-7\", \"coin\", \"/audio/jar-7.mp3\");\n  _src_managers_AudioManager_js__WEBPACK_IMPORTED_MODULE_3__.audioManager.load(\"airplane-crash-1\", \"airplane-crash\", \"/audio/airplane-crash-1.mp3\");\n  _src_managers_AudioManager_js__WEBPACK_IMPORTED_MODULE_3__.audioManager.load(\"airplane-crash-2\", \"airplane-crash\", \"/audio/airplane-crash-2.mp3\");\n  _src_managers_AudioManager_js__WEBPACK_IMPORTED_MODULE_3__.audioManager.load(\"airplane-crash-3\", \"airplane-crash\", \"/audio/airplane-crash-3.mp3\");\n  _src_managers_AudioManager_js__WEBPACK_IMPORTED_MODULE_3__.audioManager.load(\"bubble\", \"bubble\", \"/audio/bubble.mp3\");\n  _src_managers_AudioManager_js__WEBPACK_IMPORTED_MODULE_3__.audioManager.load(\"shot-soft\", \"shot-soft\", \"/audio/shot-soft.mp3\");\n  _src_managers_AudioManager_js__WEBPACK_IMPORTED_MODULE_3__.audioManager.load(\"shot-hard\", \"shot-hard\", \"/audio/shot-hard.mp3\");\n  _src_managers_AudioManager_js__WEBPACK_IMPORTED_MODULE_3__.audioManager.load(\"bullet-impact\", \"bullet-impact\", \"/audio/bullet-impact-rock.mp3\");\n  _src_managers_AudioManager_js__WEBPACK_IMPORTED_MODULE_3__.audioManager.load(\"water-splash\", \"water-splash\", \"/audio/water-splash.mp3\");\n  _src_managers_AudioManager_js__WEBPACK_IMPORTED_MODULE_3__.audioManager.load(\"rock-shatter-1\", \"rock-shatter\", \"/audio/rock-shatter-1.mp3\");\n  _src_managers_AudioManager_js__WEBPACK_IMPORTED_MODULE_3__.audioManager.load(\"rock-shatter-2\", \"rock-shatter\", \"/audio/rock-shatter-2.mp3\");\n\n  // load models\n  _src_managers_ModelManager_js__WEBPACK_IMPORTED_MODULE_5__.modelManager.load(\"heart\");\n  ui = new UI(startMap);\n  _src_managers_loadingProgressManager_js__WEBPACK_IMPORTED_MODULE_4__.loadingProgressManager.catch(err => {\n    ui.showError(err.message);\n  });\n}\nwindow.addEventListener(\"load\", onWebsiteLoaded, false);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (game = {\n  speed: 0.01,\n  canDie: true\n});\n\n//# sourceURL=webpack:///./game.js?");

/***/ }),

/***/ "./src/components/Cloud.js":
/*!*********************************!*\
  !*** ./src/components/Cloud.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ RainbowCloud)\n/* harmony export */ });\nclass RainbowCloud {\n  constructor() {\n    this.mesh = new THREE.Object3D();\n    const geom = new THREE.BoxGeometry(20, 20, 20);\n\n    // More vibrant rainbow colors\n    this.rainbowColors = [0xff0000,\n    // Bright Red\n    0xff7f00,\n    // Bright Orange\n    0xffff00,\n    // Bright Yellow\n    0x00ff00,\n    // Bright Green\n    0x0000ff,\n    // Bright Blue\n    0x8b00ff // Bright Violet\n    ];\n    const nBlocs = 5 + Math.floor(Math.random() * 3); // Increased number of blocks\n    for (let i = 0; i < nBlocs; i++) {\n      const mat = new THREE.MeshPhongMaterial({\n        color: this.rainbowColors[i % this.rainbowColors.length],\n        emissive: this.rainbowColors[i % this.rainbowColors.length],\n        emissiveIntensity: 0.5,\n        shininess: 100\n      });\n      const m = new THREE.Mesh(geom.clone(), mat);\n      m.position.x = i * 12; // Slightly closer together\n      m.position.y = Math.random() * 10;\n      m.position.z = Math.random() * 10;\n      m.rotation.y = Math.random() * Math.PI * 2;\n      m.rotation.z = Math.random() * Math.PI * 2;\n      const s = 0.8 + Math.random() * 0.5; // Larger scale\n      m.scale.set(s, s, s);\n      this.mesh.add(m);\n      m.castShadow = true;\n      m.receiveShadow = true;\n\n      // Add a glow effect\n      const glowMat = new THREE.MeshBasicMaterial({\n        color: this.rainbowColors[i % this.rainbowColors.length],\n        transparent: true,\n        opacity: 0.5\n      });\n      const glowMesh = new THREE.Mesh(geom.clone(), glowMat);\n      glowMesh.scale.multiplyScalar(1.2);\n      m.add(glowMesh);\n    }\n\n    // Add overall glow to the cloud\n    const cloudGlow = new THREE.PointLight(0xffffff, 1, 100);\n    cloudGlow.position.set(nBlocs * 6, 5, 5);\n    this.mesh.add(cloudGlow);\n  }\n  tick(deltaTime) {\n    const l = this.mesh.children.length;\n    for (let i = 0; i < l; i++) {\n      const m = this.mesh.children[i];\n      if (m instanceof THREE.Mesh) {\n        m.rotation.y += Math.random() * 0.02 * (i + 1);\n        m.rotation.z += Math.random() * 0.03 * (i + 1);\n\n        // Animate colors\n        const hue = (Date.now() * 0.001 + i * 0.1) % 1;\n        const color = new THREE.Color().setHSL(hue, 1, 0.5);\n        m.material.color.set(color);\n        m.material.emissive.set(color);\n        if (m.children[0]) {\n          m.children[0].material.color.set(color);\n        }\n\n        // Pulsating effect\n        const s = 0.8 + Math.random() * 0.5;\n        const pulseFactor = Math.sin(Date.now() * 0.005 + i) * 0.1 + 1;\n        m.scale.set(s * pulseFactor, s * pulseFactor, s * pulseFactor);\n      }\n    }\n\n    // Animate the overall glow\n    const cloudGlow = this.mesh.children[this.mesh.children.length - 1];\n    if (cloudGlow instanceof THREE.PointLight) {\n      cloudGlow.intensity = 1 + Math.sin(Date.now() * 0.005) * 0.5;\n    }\n  }\n}\n\n//# sourceURL=webpack:///./src/components/Cloud.js?");

/***/ }),

/***/ "./src/components/Pilot.js":
/*!*********************************!*\
  !*** ./src/components/Pilot.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Pilot)\n/* harmony export */ });\n/* harmony import */ var _utils_Colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/Colors */ \"./src/utils/Colors.js\");\n/* harmony import */ var _game__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../game */ \"./game.js\");\n\n\nclass Pilot {\n  constructor() {\n    this.mesh = new THREE.Object3D();\n    this.angleHairs = 0;\n    var bodyGeom = new THREE.BoxGeometry(15, 15, 15);\n    var bodyMat = new THREE.MeshPhongMaterial({\n      color: _utils_Colors__WEBPACK_IMPORTED_MODULE_0__[\"default\"].brown,\n      flatShading: true\n    });\n    var body = new THREE.Mesh(bodyGeom, bodyMat);\n    body.position.set(2, -12, 0);\n    this.mesh.add(body);\n    var faceGeom = new THREE.BoxGeometry(10, 10, 10);\n    var faceMat = new THREE.MeshLambertMaterial({\n      color: _utils_Colors__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pink\n    });\n    var face = new THREE.Mesh(faceGeom, faceMat);\n    this.mesh.add(face);\n    var hairGeom = new THREE.BoxGeometry(4, 4, 4);\n    var hairMat = new THREE.MeshLambertMaterial({\n      color: _utils_Colors__WEBPACK_IMPORTED_MODULE_0__[\"default\"].brown\n    });\n    var hair = new THREE.Mesh(hairGeom, hairMat);\n    hair.geometry.applyMatrix4(new THREE.Matrix4().makeTranslation(0, 2, 0));\n    var hairs = new THREE.Object3D();\n    this.hairsTop = new THREE.Object3D();\n    for (var i = 0; i < 12; i++) {\n      var h = hair.clone();\n      var col = i % 3;\n      var row = Math.floor(i / 3);\n      var startPosZ = -4;\n      var startPosX = -4;\n      h.position.set(startPosX + row * 4, 0, startPosZ + col * 4);\n      h.geometry.applyMatrix4(new THREE.Matrix4().makeScale(1, 1, 1));\n      this.hairsTop.add(h);\n    }\n    hairs.add(this.hairsTop);\n    var hairSideGeom = new THREE.BoxGeometry(12, 4, 2);\n    hairSideGeom.applyMatrix4(new THREE.Matrix4().makeTranslation(-6, 0, 0));\n    var hairSideR = new THREE.Mesh(hairSideGeom, hairMat);\n    var hairSideL = hairSideR.clone();\n    hairSideR.position.set(8, -2, 6);\n    hairSideL.position.set(8, -2, -6);\n    hairs.add(hairSideR);\n    hairs.add(hairSideL);\n    var hairBackGeom = new THREE.BoxGeometry(2, 8, 10);\n    var hairBack = new THREE.Mesh(hairBackGeom, hairMat);\n    hairBack.position.set(-1, -4, 0);\n    hairs.add(hairBack);\n    hairs.position.set(-5, 5, 0);\n    this.mesh.add(hairs);\n    var glassGeom = new THREE.BoxGeometry(5, 5, 5);\n    var glassMat = new THREE.MeshLambertMaterial({\n      color: _utils_Colors__WEBPACK_IMPORTED_MODULE_0__[\"default\"].brown\n    });\n    var glassR = new THREE.Mesh(glassGeom, glassMat);\n    glassR.position.set(6, 0, 3);\n    var glassL = glassR.clone();\n    glassL.position.z = -glassR.position.z;\n    var glassAGeom = new THREE.BoxGeometry(11, 1, 11);\n    var glassA = new THREE.Mesh(glassAGeom, glassMat);\n    this.mesh.add(glassR);\n    this.mesh.add(glassL);\n    this.mesh.add(glassA);\n    var earGeom = new THREE.BoxGeometry(2, 3, 2);\n    var earL = new THREE.Mesh(earGeom, faceMat);\n    earL.position.set(0, 0, -6);\n    var earR = earL.clone();\n    earR.position.set(0, 0, 6);\n    this.mesh.add(earL);\n    this.mesh.add(earR);\n  }\n  updateHairs(deltaTime) {\n    var hairs = this.hairsTop.children;\n    var l = hairs.length;\n    for (var i = 0; i < l; i++) {\n      var h = hairs[i];\n      h.scale.y = 0.75 + Math.cos(this.angleHairs + i / 3) * 0.25;\n    }\n    this.angleHairs += _game__WEBPACK_IMPORTED_MODULE_1__[\"default\"].speed * deltaTime * 40;\n  }\n}\n\n//# sourceURL=webpack:///./src/components/Pilot.js?");

/***/ }),

/***/ "./src/createAirplaneMesh.js":
/*!***********************************!*\
  !*** ./src/createAirplaneMesh.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createAirplaneMesh: () => (/* binding */ createAirplaneMesh),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _utils_Utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/Utils */ \"./src/utils/Utils.js\");\n/* harmony import */ var _utils_Colors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/Colors */ \"./src/utils/Colors.js\");\n/* harmony import */ var _components_Pilot__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/Pilot */ \"./src/components/Pilot.js\");\n\n\n\nfunction createAirplaneMesh() {\n  const mesh = new THREE.Object3D();\n\n  // Cabin\n  var matCabin = new THREE.MeshPhongMaterial({\n    color: _utils_Colors__WEBPACK_IMPORTED_MODULE_1__.Colors.red,\n    flatShading: true,\n    side: THREE.DoubleSide\n  });\n  const frontUR = [40, 25, -25];\n  const frontUL = [40, 25, 25];\n  const frontLR = [40, -25, -25];\n  const frontLL = [40, -25, 25];\n  const backUR = [-40, 15, -5];\n  const backUL = [-40, 15, 5];\n  const backLR = [-40, 5, -5];\n  const backLL = [-40, 5, 5];\n  const vertices = new Float32Array(_utils_Utils__WEBPACK_IMPORTED_MODULE_0__.utils.makeTetrahedron(frontUL, frontUR, frontLL, frontLR).concat(\n  // front\n  _utils_Utils__WEBPACK_IMPORTED_MODULE_0__.utils.makeTetrahedron(backUL, backUR, backLL, backLR)).concat(\n  // back\n  _utils_Utils__WEBPACK_IMPORTED_MODULE_0__.utils.makeTetrahedron(backUR, backLR, frontUR, frontLR)).concat(\n  // side\n  _utils_Utils__WEBPACK_IMPORTED_MODULE_0__.utils.makeTetrahedron(backUL, backLL, frontUL, frontLL)).concat(\n  // side\n  _utils_Utils__WEBPACK_IMPORTED_MODULE_0__.utils.makeTetrahedron(frontUL, backUL, frontUR, backUR)).concat(\n  // top\n  _utils_Utils__WEBPACK_IMPORTED_MODULE_0__.utils.makeTetrahedron(frontLL, backLL, frontLR, backLR)) // bottom\n  );\n  const geomCabin = new THREE.BufferGeometry();\n  geomCabin.setAttribute(\"position\", new THREE.BufferAttribute(vertices, 3));\n  var cabin = new THREE.Mesh(geomCabin, matCabin);\n  cabin.castShadow = true;\n  cabin.receiveShadow = true;\n  mesh.add(cabin);\n\n  // Engine\n\n  var geomEngine = new THREE.BoxGeometry(20, 50, 50, 1, 1, 1);\n  var matEngine = new THREE.MeshPhongMaterial({\n    color: _utils_Colors__WEBPACK_IMPORTED_MODULE_1__.Colors.white,\n    flatShading: true\n  });\n  var engine = new THREE.Mesh(geomEngine, matEngine);\n  //Ð¿Ð¾Ð·Ð¸Ñ†Ð¸Ñ\n  engine.position.x = 50;\n  engine.castShadow = true;\n  engine.receiveShadow = true;\n  mesh.add(engine);\n\n  // Tail Plane\n  var geomTailPlane = new THREE.BoxGeometry(15, 20, 5, 1, 1, 1);\n  var matTailPlane = new THREE.MeshPhongMaterial({\n    color: _utils_Colors__WEBPACK_IMPORTED_MODULE_1__.Colors.red,\n    flatShading: true\n  });\n  var tailPlane = new THREE.Mesh(geomTailPlane, matTailPlane);\n  //Ð¿Ð¾Ð·Ð¸Ñ†Ð¸Ñ\n  tailPlane.position.set(-40, 20, 0);\n  tailPlane.castShadow = true;\n  tailPlane.receiveShadow = true;\n  mesh.add(tailPlane);\n\n  // Wings\n\n  var geomSideWing = new THREE.BoxGeometry(30, 5, 120, 1, 1, 1);\n  var matSideWing = new THREE.MeshPhongMaterial({\n    color: _utils_Colors__WEBPACK_IMPORTED_MODULE_1__.Colors.red,\n    flatShading: true\n  });\n  var sideWing = new THREE.Mesh(geomSideWing, matSideWing);\n  //Ð¿Ð¾Ð·Ð¸Ñ†Ð¸Ñ\n  sideWing.position.set(0, 15, 0);\n  sideWing.castShadow = true;\n  sideWing.receiveShadow = true;\n  mesh.add(sideWing);\n  var geomWindshield = new THREE.BoxGeometry(3, 15, 20, 1, 1, 1);\n  var matWindshield = new THREE.MeshPhongMaterial({\n    color: _utils_Colors__WEBPACK_IMPORTED_MODULE_1__.Colors.white,\n    transparent: true,\n    opacity: 0.3,\n    flatShading: true\n  });\n  var windshield = new THREE.Mesh(geomWindshield, matWindshield);\n  windshield.position.set(20, 27, 0);\n  windshield.castShadow = true;\n  windshield.receiveShadow = true;\n  mesh.add(windshield);\n  var geomPropeller = new THREE.BoxGeometry(20, 10, 10, 1, 1, 1);\n  geomPropeller.attributes.position.array[4 * 3 + 1] -= 5;\n  geomPropeller.attributes.position.array[4 * 3 + 2] += 5;\n  geomPropeller.attributes.position.array[5 * 3 + 1] -= 5;\n  geomPropeller.attributes.position.array[5 * 3 + 2] -= 5;\n  geomPropeller.attributes.position.array[6 * 3 + 1] += 5;\n  geomPropeller.attributes.position.array[6 * 3 + 2] += 5;\n  geomPropeller.attributes.position.array[7 * 3 + 1] += 5;\n  geomPropeller.attributes.position.array[7 * 3 + 2] -= 5;\n  var matPropeller = new THREE.MeshPhongMaterial({\n    color: _utils_Colors__WEBPACK_IMPORTED_MODULE_1__.Colors.brown,\n    flatShading: true\n  });\n  const propeller = new THREE.Mesh(geomPropeller, matPropeller);\n  propeller.castShadow = true;\n  propeller.receiveShadow = true;\n  var geomBlade = new THREE.BoxGeometry(1, 80, 10, 1, 1, 1);\n  var matBlade = new THREE.MeshPhongMaterial({\n    color: _utils_Colors__WEBPACK_IMPORTED_MODULE_1__.Colors.brownDark,\n    flatShading: true\n  });\n  var blade1 = new THREE.Mesh(geomBlade, matBlade);\n  //Ð¿Ð¾Ð·Ð¸Ñ†Ð¸Ñ\n  blade1.position.set(8, 0, 0);\n  blade1.castShadow = true;\n  blade1.receiveShadow = true;\n  var blade2 = blade1.clone();\n  blade2.rotation.x = Math.PI / 2;\n  blade2.castShadow = true;\n  blade2.receiveShadow = true;\n  propeller.add(blade1);\n  propeller.add(blade2);\n  propeller.position.set(60, 0, 0);\n  mesh.add(propeller);\n  var wheelProtecGeom = new THREE.BoxGeometry(30, 15, 10, 1, 1, 1);\n  var wheelProtecMat = new THREE.MeshPhongMaterial({\n    color: _utils_Colors__WEBPACK_IMPORTED_MODULE_1__.Colors.red,\n    flatShading: true\n  });\n  var wheelProtecR = new THREE.Mesh(wheelProtecGeom, wheelProtecMat);\n  //Ð¿Ð¾Ð·Ð¸Ñ†Ð¸Ñ\n  wheelProtecR.position.set(25, -20, 25);\n  mesh.add(wheelProtecR);\n  var wheelTireGeom = new THREE.BoxGeometry(24, 24, 4);\n  var wheelTireMat = new THREE.MeshPhongMaterial({\n    color: _utils_Colors__WEBPACK_IMPORTED_MODULE_1__.Colors.brownDark,\n    flatShading: true\n  });\n  var wheelTireR = new THREE.Mesh(wheelTireGeom, wheelTireMat);\n  //Ð¿Ð¾Ð·Ð¸Ñ†Ð¸Ñ\n  wheelTireR.position.set(25, -28, 25);\n  var wheelAxisGeom = new THREE.BoxGeometry(10, 10, 6);\n  var wheelAxisMat = new THREE.MeshPhongMaterial({\n    color: _utils_Colors__WEBPACK_IMPORTED_MODULE_1__.Colors.brown,\n    flatShading: true\n  });\n  var wheelAxis = new THREE.Mesh(wheelAxisGeom, wheelAxisMat);\n  wheelTireR.add(wheelAxis);\n  mesh.add(wheelTireR);\n  var wheelProtecL = wheelProtecR.clone();\n  wheelProtecL.position.z = -wheelProtecR.position.z;\n  mesh.add(wheelProtecL);\n  var wheelTireL = wheelTireR.clone();\n  wheelTireL.position.z = -wheelTireR.position.z;\n  mesh.add(wheelTireL);\n  var wheelTireB = wheelTireR.clone();\n  wheelTireB.scale.set(0.5, 0.5, 0.5);\n  //Ð¿Ð¾Ð·Ð¸Ñ†Ð¸Ñ\n  wheelTireB.position.set(-35, -5, 0);\n  mesh.add(wheelTireB);\n  var suspensionGeom = new THREE.BoxGeometry(4, 20, 4);\n  suspensionGeom.applyMatrix4(new THREE.Matrix4().makeTranslation(0, 10, 0));\n  var suspensionMat = new THREE.MeshPhongMaterial({\n    color: _utils_Colors__WEBPACK_IMPORTED_MODULE_1__.Colors.red,\n    flatShading: true\n  });\n  var suspension = new THREE.Mesh(suspensionGeom, suspensionMat);\n  suspension.position.set(-35, -5, 0);\n  suspension.rotation.z = -0.3;\n  mesh.add(suspension);\n  const pilot = new _components_Pilot__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\n  pilot.mesh.position.set(5, 27, 0);\n  mesh.add(pilot.mesh);\n  mesh.castShadow = true;\n  mesh.receiveShadow = true;\n  return [mesh, propeller, pilot];\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createAirplaneMesh);\n\n//# sourceURL=webpack:///./src/createAirplaneMesh.js?");

/***/ }),

/***/ "./src/managers/AudioManager.js":
/*!**************************************!*\
  !*** ./src/managers/AudioManager.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AudioManager: () => (/* binding */ AudioManager),\n/* harmony export */   audioManager: () => (/* binding */ audioManager)\n/* harmony export */ });\n/* harmony import */ var _loadingProgressManager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loadingProgressManager.js */ \"./src/managers/loadingProgressManager.js\");\n// audioManager.js\n\nclass AudioManager {\n  constructor() {\n    this.buffers = {};\n    this.loader = new THREE.AudioLoader();\n    this.listener = new THREE.AudioListener();\n    this.categories = {};\n  }\n  setCamera(camera) {\n    camera.add(this.listener);\n  }\n  load(soundId, category, path) {\n    const promise = new Promise((resolve, reject) => {\n      this.loader.load(path, audioBuffer => {\n        this.buffers[soundId] = audioBuffer;\n        if (category !== null) {\n          if (!this.categories[category]) {\n            this.categories[category] = [];\n          }\n          this.categories[category].push(soundId);\n        }\n        resolve();\n      }, () => {}, reject);\n    });\n    _loadingProgressManager_js__WEBPACK_IMPORTED_MODULE_0__.loadingProgressManager.add(promise);\n  }\n  play(soundIdOrCategory, options = {}) {\n    let soundId = soundIdOrCategory;\n    const category = this.categories[soundIdOrCategory];\n    if (category) {\n      soundId = category[Math.floor(Math.random() * category.length)];\n    }\n    const buffer = this.buffers[soundId];\n    const sound = new THREE.Audio(this.listener);\n    sound.setBuffer(buffer);\n    if (options.loop) {\n      sound.setLoop(true);\n    }\n    if (options.volume) {\n      sound.setVolume(options.volume);\n    }\n    sound.play();\n  }\n}\nconst audioManager = new AudioManager();\n\n//# sourceURL=webpack:///./src/managers/AudioManager.js?");

/***/ }),

/***/ "./src/managers/ModelManager.js":
/*!**************************************!*\
  !*** ./src/managers/ModelManager.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ModelManager: () => (/* binding */ ModelManager),\n/* harmony export */   modelManager: () => (/* binding */ modelManager)\n/* harmony export */ });\n/* harmony import */ var _loadingProgressManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loadingProgressManager */ \"./src/managers/loadingProgressManager.js\");\n\nclass ModelManager {\n  constructor(path) {\n    this.path = path;\n    this.models = {};\n  }\n  load(modelName) {\n    const promise = new Promise((resolve, reject) => {\n      const loader = new THREE.OBJLoader();\n      loader.load(this.path + \"/\" + modelName + \".obj\", obj => {\n        this.models[modelName] = obj;\n        resolve();\n      }, function () {}, reject);\n    });\n    _loadingProgressManager__WEBPACK_IMPORTED_MODULE_0__.loadingProgressManager.add(promise);\n  }\n  get(modelName) {\n    if (typeof this.models[modelName] === \"undefined\") {\n      throw new Error(\"Can't find model \" + modelName);\n    }\n    return this.models[modelName];\n  }\n}\nconst modelManager = new ModelManager(\"/models\");\n\n//# sourceURL=webpack:///./src/managers/ModelManager.js?");

/***/ }),

/***/ "./src/managers/loadingProgressManager.js":
/*!************************************************!*\
  !*** ./src/managers/loadingProgressManager.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LoadingProgressManager: () => (/* binding */ LoadingProgressManager),\n/* harmony export */   loadingProgressManager: () => (/* binding */ loadingProgressManager)\n/* harmony export */ });\n// src/managers/LoadingProgressManager.js\n\nclass LoadingProgressManager {\n  constructor() {\n    this.promises = [];\n  }\n  add(promise) {\n    this.promises.push(promise);\n  }\n  then(callback) {\n    return Promise.all(this.promises).then(callback);\n  }\n  catch(callback) {\n    return Promise.all(this.promises).catch(callback);\n  }\n}\nconst loadingProgressManager = new LoadingProgressManager();\n\n//# sourceURL=webpack:///./src/managers/loadingProgressManager.js?");

/***/ }),

/***/ "./src/utils/Colors.js":
/*!*****************************!*\
  !*** ./src/utils/Colors.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   COLOR_COINS: () => (/* binding */ COLOR_COINS),\n/* harmony export */   COLOR_COLLECTIBLE_BUBBLE: () => (/* binding */ COLOR_COLLECTIBLE_BUBBLE),\n/* harmony export */   COLOR_SEA_LEVEL: () => (/* binding */ COLOR_SEA_LEVEL),\n/* harmony export */   Colors: () => (/* binding */ Colors),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// src/utils/Colors.js\n\nconst Colors = {\n  red: 0xf25346,\n  orange: 0xffa500,\n  white: 0xd8d0d1,\n  brown: 0x59332e,\n  brownDark: 0x23190f,\n  pink: 0xf5986e,\n  yellow: 0xf4ce93,\n  blue: 0x68c3c0,\n  lightPurple: 0xc8a2c8\n};\n\n// Named exports for specific game elements\nconst COLOR_COINS = 0xffd700;\nconst COLOR_COLLECTIBLE_BUBBLE = COLOR_COINS;\nconst COLOR_SEA_LEVEL = [0x68c3c0,\n// hsl(178deg 43% 59%)\n0x47b3af,\n// hsl(178deg 43% 49%)\n0x398e8b,\n// hsl(178deg 43% 39%)\n0x2a6a68,\n// hsl(178deg 43% 29%)\n0x1c4544,\n// hsl(178deg 43% 19%)\n0x0d2120 // hsl(178deg 43% 09%)\n];\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Colors);\n\n//# sourceURL=webpack:///./src/utils/Colors.js?");

/***/ }),

/***/ "./src/utils/Utils.js":
/*!****************************!*\
  !*** ./src/utils/Utils.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   utils: () => (/* binding */ utils)\n/* harmony export */ });\n// src/utils/Utils.js\n\nconst utils = {\n  normalize: function (v, vmin, vmax, tmin, tmax) {\n    var nv = Math.max(Math.min(v, vmax), vmin);\n    var dv = vmax - vmin;\n    var pc = (nv - vmin) / dv;\n    var dt = tmax - tmin;\n    var tv = tmin + pc * dt;\n    return tv;\n  },\n  findWhere: function (list, properties) {\n    for (const elem of list) {\n      let all = true;\n      for (const key in properties) {\n        if (elem[key] !== properties[key]) {\n          all = false;\n          break;\n        }\n      }\n      if (all) {\n        return elem;\n      }\n    }\n    return null;\n  },\n  randomOneOf: function (choices) {\n    return choices[Math.floor(Math.random() * choices.length)];\n  },\n  randomFromRange: function (min, max) {\n    return min + Math.random() * (max - min);\n  },\n  collide: function (mesh1, mesh2, tolerance) {\n    const diffPos = mesh1.position.clone().sub(mesh2.position.clone());\n    const d = diffPos.length();\n    return d < tolerance;\n  },\n  makeTetrahedron: function (a, b, c, d) {\n    return [a[0], a[1], a[2], b[0], b[1], b[2], c[0], c[1], c[2], b[0], b[1], b[2], c[0], c[1], c[2], d[0], d[1], d[2]];\n  }\n};\n\n//# sourceURL=webpack:///./src/utils/Utils.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./game.js");
/******/ 	
/******/ })()
;